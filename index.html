<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BookBlue</title>
  <!-- 添加全局变量来跟踪库加载状态 -->
  <script>
    window.librariesReady = false;
    window.librariesLoading = true;
  </script>

  <!-- 引入JSZip库 - ePub.js的依赖 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <!-- 引入ePub.js库 -->
  <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

  <!-- 库加载管理 -->
  <script>
    // 检查库是否已加载
    function checkLibraries() {
      const jszipLoaded = typeof JSZip !== 'undefined';
      const epubLoaded = typeof ePub !== 'undefined';

      if (jszipLoaded && epubLoaded) {

        window.librariesReady = true;
        window.librariesLoading = false;

        // 更新UI状态
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }

        const dropArea = document.getElementById('drop-area');
        if (dropArea) {
          dropArea.classList.remove('disabled');
          const loadingText = dropArea.querySelector('.loading-text');
          if (loadingText) {
            loadingText.style.display = 'none';
          }
        }

        return true;
      }

      return false;
    }

    // 尝试加载备用库源
    function loadAlternateLibraries() {
      if (typeof JSZip === 'undefined') {
        var jszipScript = document.createElement('script');
        jszipScript.src = 'https://unpkg.com/jszip@3.10.1/dist/jszip.min.js';
        jszipScript.onload = function() {
          checkLibraries();
        };
        document.head.appendChild(jszipScript);
      }

      if (typeof ePub === 'undefined') {
        var epubScript = document.createElement('script');
        epubScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/epub.js/0.3.88/epub.min.js';
        epubScript.onload = function() {
          checkLibraries();
        };
        document.head.appendChild(epubScript);
      }
    }

    // 页面加载完成后检查库
    window.addEventListener('load', function() {
      if (!checkLibraries()) {
        loadAlternateLibraries();

        // 5秒后再次检查
        setTimeout(function() {
          if (!window.librariesReady) {
            console.error('Failed to load libraries after timeout');
            alert('Failed to load required libraries. Please check your internet connection and try again.');
          }
        }, 5000);
      }
    });
  </script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Noto Serif', Georgia, serif;
      background-color: #f5f2e9;
      height: 100vh;
      overflow: hidden;
    }

    /* Dropbox 授权按钮样式 */
    #dropbox-auth-button {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      padding: 5px 10px;
      background-color: #0061fe;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }



    .container {
      display: flex;
      height: 100vh;
      width: 100%;
    }

    .reader-area {
      flex: 1;
      height: 100%;
      position: relative;
      background-color: #fff;
      overflow: hidden;
      cursor: default; /* 使用默认光标，不显示文本选择光标 */
    }

    .notes-area {
      width: 30px; /* 默认收起状态的宽度 */
      background-color: #f5f2e9;
      height: 100%;
      position: relative;
      transition: width 0.3s ease;
      overflow: hidden;
      box-shadow: -1px 0 3px rgba(0, 0, 0, 0.05);
    }

    .notes-area.expanded {
      width: 350px; /* 展开状态的宽度 */
    }

    .notes-toggle {
      position: absolute;
      left: 0;
      top: 0;
      width: 30px;
      height: 100%;
      background-color: #f5f2e9;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .notes-toggle:hover {
      background-color: #ebe5d6;
    }

    .notes-toggle::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      width: 2px;
      background-color: #4a4238;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .notes-toggle:hover::after {
      opacity: 0.15;
    }

    .notes-toggle .icon {
      font-size: 16px;
      color: #8a7a6a;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0.7;
      transition: opacity 0.2s ease, color 0.2s ease;
    }

    .notes-toggle:hover .icon {
      opacity: 1;
      color: #4a4238;
    }

    .notes-content {
      position: absolute;
      left: 30px;
      top: 0;
      width: calc(100% - 30px);
      height: 100%;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s;
    }

    .notes-area.expanded .notes-content {
      opacity: 1;
      visibility: visible;
    }

    #epub-container {
      width: 100%;
      height: calc(100% - 30px); /* 减少高度，为页码留出空间 */
      position: relative;
      overflow: hidden;
    }

    .drop-area {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-color: rgba(255, 255, 255, 0.9);
      border: 3px dashed #ccc;
      z-index: 10;
      transition: all 0.3s ease;
    }

    .drop-area.hidden {
      display: none;
    }

    .drop-area.disabled {
      opacity: 0.7;
      pointer-events: none;
      border-color: #999;
    }

    .loading-indicator {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #4a4238;
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 100;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .loading-indicator::after {
      content: "...";
      animation: dots 1.5s infinite;
    }

    @keyframes dots {
      0%, 20% { content: "."; }
      40% { content: ".."; }
      60%, 100% { content: "..."; }
    }

    .loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a4238;
      font-size: 1.2rem;
      z-index: 2;
    }

    /* 页码显示 - 极简风格，只有数字 */
    .page-counter {
      position: absolute;
      bottom: 8px;
      right: 15px;
      font-size: 14px;
      color: #4a4238;
      z-index: 10;
      user-select: none;
    }

    .plus-container {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #4a4238;
      color: white;
      margin: 0 auto;
    }

    .plus-icon {
      font-size: 3rem;
      line-height: 1;
      display: block;
    }

    #file-input {
      display: none;
    }

    #select-file-btn {
      padding: 0.7rem 1.2rem;
      background-color: #4a4238;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    #select-file-btn:hover {
      background-color: #5d5347;
    }

    #notes {
      width: 100%;
      height: 100%;
      padding: 1.5rem;
      resize: none;
      font-family: inherit;
      background-color: transparent;
      line-height: 1.6;
      border: none;
      outline: none;
      color: #4a4238;
      box-sizing: border-box;
    }

    /* 极简界面，移除了页面信息样式 */

    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }

      .notes-area {
        width: 100%;
        height: 200px;
      }
    }

    /* 顶部抽屉样式 */
    .drawer-trigger {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 8px;
      background-color: rgba(74, 66, 56, 0.1);
      z-index: 1000;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    .drawer-trigger:hover {
      background-color: rgba(74, 66, 56, 0.2);
    }

    .trigger-indicator {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 60px;
      height: 4px;
      background-color: rgba(74, 66, 56, 0.5);
      border-radius: 0 0 4px 4px;
      transition: all 0.3s ease;
    }

    .drawer-trigger:hover .trigger-indicator {
      background-color: rgba(74, 66, 56, 0.8);
      height: 6px;
    }

    .top-drawer {
      position: fixed;
      top: -240px; /* 初始状态隐藏 - 增加到原来的三倍 */
      left: 0;
      width: 100%;
      height: 240px; /* 固定高度 - 增加到原来的三倍 */
      background-color: rgba(74, 66, 56, 0.9);
      z-index: 999;
      transition: top 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(5px);
    }

    .top-drawer.open {
      top: 0;
    }

    .drawer-content {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }

    /* Dropbox 连接容器 */
    .dropbox-connect-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
      padding: 0 20px;
    }

    .dropbox-auth-button {
      background-color: #0061fe;
      border: none;
      color: white;
      padding: 10px 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      border-radius: 4px;
      font-size: 16px;
      font-weight: 500;
      transition: background-color 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .dropbox-auth-button:hover {
      background-color: #0052d9;
    }

    .button-icon {
      margin-right: 8px;
      font-size: 18px;
    }

    .connect-description {
      margin-top: 8px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
    }

    /* Dropbox 书籍容器 */
    .dropbox-books-container {
      display: flex;
      align-items: center;
      height: 100%;
      width: 100%;
      padding: 0 20px;
      overflow-x: auto; /* 只允许横向滚动 */
      overflow-y: hidden; /* 禁止纵向滚动 */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE and Edge */
      white-space: nowrap;
      user-select: none; /* 防止文本选择，便于拖动 */
    }

    /* 隐藏 WebKit 滚动条 */
    .dropbox-books-container::-webkit-scrollbar {
      display: none;
    }

    /* 移除了滚动条样式 */

    /* 书籍网格 */
    .books-grid {
      display: flex;
      gap: 15px;
      align-items: center;
      height: 100%;
      flex-grow: 1;
    }

    .book-card {
      width: 140px; /* 增加宽度以更好地显示封面 */
      height: 180px; /* 增加高度以更好地显示封面 */
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
      position: relative;
      flex-shrink: 0;
      margin-right: 15px; /* 增加间距 */
      margin-top: 15px; /* 增加顶部间距 */
      margin-bottom: 15px; /* 增加底部间距 */
    }

    .book-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
    }

    .book-cover {
      height: 100%;
      background-color: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #4a4238;
      font-size: 24px; /* 首字母显示时的字体大小 */
      position: relative;
      overflow: hidden;
      border-radius: 4px; /* 圆角边框 */
    }

    /* 封面加载指示器样式 */
    .cover-loading {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(0, 0, 0, 0.1);
      color: #4a4238;
      font-size: 14px;
    }

    /* 封面加载指示器动画 */
    .cover-loading:after {
      content: '';
      animation: coverLoadingDots 1.5s infinite;
    }

    @keyframes coverLoadingDots {
      0%, 20% { content: "."; }
      40% { content: ".."; }
      60%, 100% { content: "..."; }
    }

    .book-info {
      display: none; /* 隐藏书籍信息，只在悬停时显示 */
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 4px;
      transition: opacity 0.2s;
    }

    .book-card:hover .book-info {
      display: block;
    }

    .book-title {
      font-size: 8px;
      font-weight: bold;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: white;
      text-align: center;
    }

    .book-meta {
      display: none; /* 隐藏元数据，简化界面 */
    }

    .upload-area {
      width: 140px; /* 与书籍卡片宽度一致 */
      height: 180px; /* 与书籍卡片高度一致 */
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background-color 0.2s;
      flex-shrink: 0;
      margin-right: 15px; /* 增加间距 */
      margin-top: 15px; /* 增加顶部间距 */
      margin-bottom: 15px; /* 增加底部间距 */
    }

    .upload-area:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    .upload-icon {
      font-size: 24px;
      color: white;
    }

    .upload-text {
      display: none; /* 隐藏文字，只显示图标 */
    }

    /* 响应式调整 */
    @media (max-width: 600px) {
      .button-text {
        display: none; /* 在小屏幕上只显示图标 */
      }

      .drawer-button {
        margin-right: 10px;
      }

      .top-drawer {
        height: 240px; /* 保持与大屏幕一致 */
        top: -240px; /* 初始状态隐藏 */
      }

      .book-card {
        width: 120px; /* 在小屏幕上稍微减小宽度 */
        height: 160px; /* 在小屏幕上稍微减小高度 */
        margin: 10px; /* 减小间距 */
      }

      .book-cover {
        font-size: 12px; /* 在小屏幕上增加字体大小 */
      }

      .upload-area {
        width: 120px; /* 与书籍卡片保持一致 */
        height: 160px; /* 与书籍卡片保持一致 */
        margin: 10px; /* 减小间距 */
      }
    }
  </style>
</head>
<body>
  <!-- 顶部抽屉触发区域 -->
  <div id="drawer-trigger" class="drawer-trigger">
    <div class="trigger-indicator"></div>
  </div>

  <!-- 顶部抽屉导航 -->
  <div id="top-drawer" class="top-drawer">
    <div class="drawer-content">
      <!-- 未连接 Dropbox 状态 -->
      <div id="dropbox-connect-container" class="dropbox-connect-container">
        <button id="dropbox-auth-button" class="dropbox-auth-button">
          <span class="button-icon">🔄</span>
          <span class="button-text">连接至 Dropbox</span>
        </button>
        <div class="connect-description">连接 Dropbox 以访问您的电子书</div>
      </div>

      <!-- 已连接 Dropbox 状态 - 书库内容 -->
      <div id="dropbox-books-container" class="dropbox-books-container" style="display: none;">
        <div id="books-grid" class="books-grid">
          <!-- 书籍将在这里动态添加 -->
        </div>

        <div id="upload-area" class="upload-area">
          <div class="upload-icon">+</div>
          <input type="file" id="upload-book" accept=".epub" style="display: none;">
        </div>
      </div>
    </div>
  </div>



  <div class="container">
    <div class="reader-area">
      <!-- 单一容器用于ePub.js渲染 -->
      <div id="epub-container"></div>

      <!-- 加载指示器 -->
      <div id="loading-indicator" class="loading-indicator">Loading libraries</div>

      <!-- 页码显示 -->
      <div id="page-counter" class="page-counter"></div>

      <!-- 移除了紧急翻页按钮 -->

      <div id="drop-area" class="drop-area disabled">
        <div class="loading-text">Loading...</div>
        <div class="plus-container">
          <span class="plus-icon">+</span>
        </div>
      </div>
      <!-- 极简界面，移除了导航条 -->
    </div>

    <div class="notes-area" id="notes-area">
      <div class="notes-toggle" id="notes-toggle">
        <span class="icon">></span>
      </div>
      <div class="notes-content">
        <textarea id="notes" placeholder="Click here to write your notes..."></textarea>
      </div>
    </div>
  </div>

  <script>
    // 防抖函数 - 用于延迟执行频繁触发的函数
    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    // 进度同步模块 - 用于在Dropbox和本地之间同步阅读进度
    const progressSync = {
      // 保存所有书籍的进度信息
      progressData: {},

      // 当前在读书籍
      currentReadingBook: null,

      // 从Dropbox加载进度信息
      async loadFromDropbox() {
        try {
          const accessToken = localStorage.getItem('dropboxAccessToken');
          if (!accessToken) return false;

          console.log('从Dropbox加载阅读进度...');

          // 进度文件路径 - 放在书籍目录下
          const progressFilePath = '/BookBlue_Progress.json';

          // 尝试从Dropbox获取进度文件
          const response = await fetch('https://content.dropboxapi.com/2/files/download', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/octet-stream',
              'Dropbox-API-Arg': JSON.stringify({ path: progressFilePath })
            }
          });

          // 如果文件不存在，创建一个空的进度数据并初始化文件
          if (response.status === 409) {
            console.log('Dropbox中没有进度文件，创建新的进度数据');
            this.progressData = {};
            this.syncFromLocal(); // 从本地同步现有数据

            // 立即创建进度文件
            await this.saveToDropbox();
            console.log('已在Dropbox中创建进度文件');

            return true;
          }

          if (!response.ok) {
            console.error('从Dropbox加载进度失败:', response.status);
            return false;
          }

          // 解析进度数据
          const data = await response.json();
          console.log('从Dropbox加载的进度数据:', data);
          this.progressData = data;

          // 获取当前在读书籍
          if (data._currentBook) {
            this.currentReadingBook = data._currentBook;
            console.log('当前在读书籍:', this.currentReadingBook);
          }

          // 同步到localStorage
          this.syncToLocal();
          return true;
        } catch (error) {
          console.error('从Dropbox加载进度失败:', error);
          return false;
        }
      },

      // 保存进度到Dropbox
      async saveToDropbox() {
        try {
          const accessToken = localStorage.getItem('dropboxAccessToken');
          if (!accessToken) {
            console.log('未连接Dropbox，无法保存进度');
            return false;
          }

          console.log('保存阅读进度到Dropbox...');

          // 同步本地进度到内存
          this.syncFromLocal();

          // 保存当前在读书籍
          if (window.currentBook) {
            this.progressData._currentBook = window.currentBook;
            this.currentReadingBook = window.currentBook;
          }

          // 进度文件路径 - 与loadFromDropbox保持一致
          const progressFilePath = '/BookBlue_Progress.json';

          // 将进度数据转换为JSON字符串
          const progressContent = JSON.stringify(this.progressData, null, 2); // 使用格式化的JSON，便于阅读

          console.log('准备保存进度到Dropbox:', progressFilePath);
          console.log('进度数据:', JSON.stringify(this.progressData));

          // 上传到Dropbox
          console.log('发送保存进度请求...');
          const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/octet-stream',
              'Dropbox-API-Arg': JSON.stringify({
                path: progressFilePath,
                mode: 'overwrite'
              })
            },
            body: progressContent
          });

          console.log(`保存进度响应状态: ${response.status}`);

          if (!response.ok) {
            const errorText = await response.text();
            console.error('保存进度到Dropbox失败:', response.status, errorText);
            return false;
          }

          // 解析响应
          const result = await response.json();
          console.log('成功保存进度到Dropbox:', result);
          return true;
        } catch (error) {
          console.error('保存进度到Dropbox失败:', error);
          return false;
        }
      },

      // 从localStorage同步到内存
      syncFromLocal() {
        // 遍历localStorage，找出所有进度信息
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.endsWith('-progress')) {
            const bookName = key.replace('-progress', '');
            this.progressData[bookName] = localStorage.getItem(key);
          }
        }

        // 同步当前在读书籍
        if (window.currentBook) {
          this.progressData._currentBook = window.currentBook;
          this.currentReadingBook = window.currentBook;
        }
      },

      // 从内存同步到localStorage
      syncToLocal() {
        // 将内存中的进度信息保存到localStorage
        for (const bookName in this.progressData) {
          // 跳过特殊键
          if (bookName === '_currentBook') continue;

          localStorage.setItem(`${bookName}-progress`, this.progressData[bookName]);
        }

        // 同步当前在读书籍
        if (this.currentReadingBook) {
          // 不直接设置window.currentBook，因为这需要在加载书籍时设置
          localStorage.setItem('_currentReadingBook', this.currentReadingBook);
        }
      },

      // 更新单本书的进度
      updateBookProgress(bookName, progress, saveToCloud = true) {
        console.log(`更新书籍进度: ${bookName}, 位置: ${progress}, 保存到云端: ${saveToCloud}`);

        // 保存到localStorage
        localStorage.setItem(`${bookName}-progress`, progress);

        // 更新内存中的数据
        this.progressData[bookName] = progress;

        // 更新当前在读书籍
        this.progressData._currentBook = bookName;
        this.currentReadingBook = bookName;

        // 如果需要保存到云端
        if (saveToCloud) {
          // 保存到Dropbox
          this.saveToDropbox().then(success => {
            if (success) {
              console.log('成功保存进度到Dropbox');
            } else {
              console.warn('保存进度到Dropbox失败，将在稍后重试');
              // 如果保存失败，使用节流函数稍后重试
              this.debouncedSaveToDropbox();
            }
          }).catch(error => {
            console.error('保存进度到Dropbox时出错:', error);
            // 出错时使用节流函数稍后重试
            this.debouncedSaveToDropbox();
          });
        }
      },

      // 加载当前在读书籍
      async loadCurrentBook() {
        // 如果没有当前在读书籍，返回false
        if (!this.currentReadingBook) {
          console.log('没有当前在读书籍');
          return false;
        }

        console.log('尝试加载当前在读书籍:', this.currentReadingBook);

        // 检查是否已连接Dropbox
        const accessToken = localStorage.getItem('dropboxAccessToken');
        if (!accessToken) {
          console.log('未连接Dropbox，无法加载书籍');
          return false;
        }

        // 检查handleFile函数是否已定义
        if (typeof window.handleFile !== 'function') {
          console.log('handleFile函数尚未定义，等待DOMContentLoaded事件...');

          // 等待DOMContentLoaded事件
          return new Promise((resolve) => {
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', async () => {
                // DOMContentLoaded事件触发后，handleFile函数应该已定义
                // 递归调用自身
                const result = await this.loadCurrentBook();
                resolve(result);
              });
            } else {
              // 如果文档已加载完成但handleFile仍未定义，可能是其他原因
              console.error('文档已加载但handleFile函数未定义');
              resolve(false);
            }
          });
        }

        try {
          // 首先尝试列出所有EPUB文件，然后在本地进行匹配
          console.log('列出所有EPUB文件...');
          const listResponse = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              path: '',
              recursive: true,
              include_media_info: false,
              include_deleted: false,
              include_has_explicit_shared_members: false,
              include_mounted_folders: true,
              include_non_downloadable_files: false
            })
          });

          if (!listResponse.ok) {
            console.error('列出文件失败:', listResponse.status);
            return false;
          }

          const listResult = await listResponse.json();
          console.log('找到文件数量:', listResult.entries.length);

          // 过滤出所有EPUB文件
          const epubFiles = listResult.entries.filter(entry =>
            entry.name.toLowerCase().endsWith('.epub') && entry['.tag'] === 'file'
          );

          console.log('找到EPUB文件数量:', epubFiles.length);

          // 尝试找到精确匹配的书籍
          let exactMatch = null;
          for (const file of epubFiles) {
            if (file.name === this.currentReadingBook) {
              exactMatch = file;
              break;
            }
          }

          // 如果找到精确匹配，直接使用loadBookFromDropbox加载它
          if (exactMatch) {
            console.log('找到精确匹配的书籍:', exactMatch.name);

            // 使用与loadBookFromDropbox相同的方法加载书籍
            const path = exactMatch.path_lower;
            console.log(`正在从Dropbox加载书籍: ${path}`);

            // 使用Dropbox官方推荐的方式处理API参数
            const argObj = { path: path };
            const safeArg = httpHeaderSafeJson(argObj);

            console.log('安全编码后的Dropbox API参数:', safeArg);

            // 创建请求头
            const headers = {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/octet-stream',
              'Dropbox-API-Arg': safeArg
            };

            // 下载文件
            const response = await fetch('https://content.dropboxapi.com/2/files/download', {
              method: 'POST',
              headers: headers
            });

            if (!response.ok) {
              console.error('从Dropbox下载书籍失败:', response.status);
              return false;
            }

            // 获取文件内容
            const arrayBuffer = await response.arrayBuffer();

            // 获取文件名
            const fileName = path.split('/').pop();

            // 创建Blob和File对象
            const blob = new Blob([arrayBuffer], {type: 'application/epub+zip'});
            const file = new File([blob], fileName, {type: 'application/epub+zip'});

            console.log('创建的File对象:', file);

            // 再次检查handleFile函数是否已定义
            if (typeof window.handleFile !== 'function') {
              console.error('handleFile函数未定义，无法加载书籍');
              return false;
            }

            // 处理文件
            window.handleFile(file);

            // 如果有保存的进度，加载到该位置
            if (this.progressData[fileName]) {
              const progress = parseInt(this.progressData[fileName]);
              console.log(`加载保存的阅读进度: ${progress}`);

              // 等待书籍加载完成后设置位置
              setTimeout(() => {
                if (window.book && window.updatePages) {
                  window.updatePages(progress);
                }
              }, 1000);
            }

            return true;
          }

          // 如果没有精确匹配，尝试模糊匹配
          console.log('未找到精确匹配，尝试模糊匹配...');

          // 从当前书籍名称中提取主要部分（去掉括号内容和扩展名）
          const mainBookName = this.currentReadingBook.split('(')[0].trim().replace('.epub', '');

          // 尝试找到包含主要书名的书籍
          let fuzzyMatch = null;
          for (const file of epubFiles) {
            if (file.name.includes(mainBookName)) {
              fuzzyMatch = file;
              break;
            }
          }

          // 如果找到模糊匹配，加载它
          if (fuzzyMatch) {
            console.log('找到模糊匹配的书籍:', fuzzyMatch.name);
            await loadBookFromDropbox(fuzzyMatch.path_lower);
            return true;
          }

          console.log('未找到书籍:', this.currentReadingBook);
          return false;
        } catch (error) {
          console.error('加载当前在读书籍失败:', error);
          return false;
        }
      },

      // 节流保存函数
      debouncedSaveToDropbox: null
    };

    // 初始化节流函数
    progressSync.debouncedSaveToDropbox = debounce(() => {
      progressSync.saveToDropbox();
    }, 5000); // 5秒内只保存一次

    // Dropbox 配置
    // 注意：如果您要在其他设备上使用，请修改以下配置
    const dropboxConfig = {
      // 您的 Dropbox 应用密钥 (https://www.dropbox.com/developers/apps)
      clientId: '6swvs08dx2uakdi',

      // 您的 Dropbox 应用密钥对应的密钥
      // 注意：这是敏感信息，生产环境中不应该硬编码
      clientSecret: 'bjyje0f7g4wrlg6',  // 请从 Dropbox 开发者控制台获取并填写

      // 重定向 URI - 使用完整的当前页面 URL (包括路径)
      // 这样可以确保与 Dropbox 应用设置中的重定向 URI 匹配
      get redirectUri() {
        // 使用完整的当前页面 URL，而不仅仅是 origin
        return window.location.href.split('?')[0].split('#')[0];
      }
    };

    // Dropbox 授权函数
    async function handleDropboxAuth() {
      console.log('开始 Dropbox 授权流程...');

      // 检查是否设置了 client_secret
      if (!dropboxConfig.clientSecret) {
        alert('请先设置 Dropbox 应用密钥对应的密钥（client_secret）。');
        return;
      }

      try {
        // 获取重定向 URL
        const redirectUrl = dropboxConfig.redirectUri;
        console.log(`使用重定向 URL: ${redirectUrl}`);

        // 生成随机状态参数，防止 CSRF 攻击
        const state = Math.random().toString(36).substring(2, 15);
        localStorage.setItem('dropboxAuthState', state);

        // 构建授权 URL
        const authUrl = new URL('https://www.dropbox.com/oauth2/authorize');
        authUrl.searchParams.append('client_id', dropboxConfig.clientId);
        authUrl.searchParams.append('response_type', 'code');
        authUrl.searchParams.append('redirect_uri', redirectUrl);
        authUrl.searchParams.append('state', state);
        authUrl.searchParams.append('scope', 'files.content.read files.content.write files.metadata.read');
        authUrl.searchParams.append('token_access_type', 'offline');

        // 直接跳转到授权页面
        const authUrlString = authUrl.toString();
        console.log(`授权 URL: ${authUrlString}`);

        // 跳转到 Dropbox 授权页面
        window.location.href = authUrlString;
      } catch (error) {
        console.error('生成授权 URL 时出错:', error);
        alert('连接 Dropbox 时出错，请重试。');
      }
    }

    // 处理授权重定向
    function handleDropboxRedirect() {
      console.log('检查 URL 中是否有授权码...');
      console.log('当前 URL:', window.location.href);
      console.log('使用的重定向 URI:', dropboxConfig.redirectUri);

      // 检查 URL 中是否包含授权码
      const urlParams = new URLSearchParams(window.location.search);
      const authCode = urlParams.get('code');
      const state = urlParams.get('state');
      const error = urlParams.get('error');
      const errorDescription = urlParams.get('error_description');

      // 检查是否有错误
      if (error) {
        console.log(`授权失败: ${error}`);
        if (errorDescription) {
          console.log(`错误描述: ${errorDescription}`);
        }

        // 显示更详细的错误信息，包括重定向 URI
        let errorMessage = `Dropbox 授权失败: ${error}`;
        if (errorDescription) {
          errorMessage += `\n错误描述: ${errorDescription}`;
        }
        errorMessage += `\n\n请确保在 Dropbox 开发者控制台中设置的重定向 URI 与以下值匹配:\n${dropboxConfig.redirectUri}`;

        alert(errorMessage);
        return;
      }

      // 验证状态参数
      const savedState = localStorage.getItem('dropboxAuthState');
      if (state && savedState && state !== savedState) {
        console.log('状态参数不匹配，可能是 CSRF 攻击');
        alert('安全验证失败：状态参数不匹配');
        return;
      }

      if (authCode) {
        console.log('从 URL 中获取到授权码');
        console.log(`授权码: ${authCode.substring(0, 5)}...${authCode.substring(authCode.length - 5)}`);

        // 清除 URL 中的授权码
        window.history.replaceState(null, null, window.location.pathname);

        // 使用授权码交换访问令牌
        exchangeCodeForToken(authCode);

        // 清除状态参数
        localStorage.removeItem('dropboxAuthState');
      }
    }

    // 使用授权码交换访问令牌
    async function exchangeCodeForToken(code) {
      console.log('使用授权码交换访问令牌...');

      try {
        // 准备请求数据
        const data = new URLSearchParams();
        data.append('code', code);
        data.append('grant_type', 'authorization_code');
        data.append('client_id', dropboxConfig.clientId);
        data.append('redirect_uri', dropboxConfig.redirectUri);

        // 添加 client_secret 参数（如果有）
        if (dropboxConfig.clientSecret) {
          data.append('client_secret', dropboxConfig.clientSecret);
        } else {
          console.warn('警告: 缺少 client_secret，这可能导致令牌请求失败');
          alert('请在代码中设置 Dropbox 应用密钥对应的密钥（client_secret）。\n\n您可以在 Dropbox 开发者控制台中找到它。');
          return;
        }

        console.log('发送令牌请求...');

        // 发送请求
        const response = await fetch('https://api.dropboxapi.com/oauth2/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          body: data
        });

        console.log(`令牌响应状态: ${response.status}`);

        if (!response.ok) {
          const errorText = await response.text();
          console.log(`获取令牌失败: ${errorText}`);
          console.log('请求参数:', {
            code: code,
            grant_type: 'authorization_code',
            client_id: dropboxConfig.clientId,
            redirect_uri: dropboxConfig.redirectUri
          });

          // 提供更详细的错误信息和解决方案
          let errorMessage = `获取访问令牌失败 (${response.status}): ${errorText}\n\n`;
          errorMessage += '可能的原因:\n';
          errorMessage += '1. 重定向 URI 不匹配 - 请确保在 Dropbox 开发者控制台中设置的重定向 URI 与以下值完全匹配:\n';
          errorMessage += `   ${dropboxConfig.redirectUri}\n`;
          errorMessage += '2. client_id 或 client_secret 不正确\n';
          errorMessage += '3. 授权码已过期或已被使用\n\n';
          errorMessage += '请检查浏览器控制台以获取更多信息。';

          alert(errorMessage);
          return;
        }

        // 解析响应
        const result = await response.json();
        console.log('成功获取访问令牌');

        const accessToken = result.access_token;
        const refreshToken = result.refresh_token;
        const expiresIn = result.expires_in;
        const tokenType = result.token_type;

        console.log(`访问令牌: ${accessToken.substring(0, 5)}...${accessToken.substring(accessToken.length - 5)}`);
        if (refreshToken) {
          console.log(`刷新令牌: ${refreshToken.substring(0, 5)}...${refreshToken.substring(refreshToken.length - 5)}`);
        }
        console.log(`过期时间: ${expiresIn}秒`);
        console.log(`令牌类型: ${tokenType}`);

        // 保存令牌
        localStorage.setItem('dropboxAccessToken', accessToken);
        if (refreshToken) {
          localStorage.setItem('dropboxRefreshToken', refreshToken);
        }

        // 保存令牌获取时间和过期时间
        const now = new Date().getTime();
        localStorage.setItem('dropboxTokenTime', now);
        if (expiresIn) {
          const expiryTime = now + (parseInt(expiresIn) * 1000);
          localStorage.setItem('dropboxTokenExpiry', expiryTime);
          console.log(`令牌将在 ${new Date(expiryTime).toLocaleString()} 过期`);
        }

        // 更新 UI 状态
        updateDropboxAuthUI(true);

        // 尝试加载阅读进度和上次阅读的书籍
        try {
          console.log('授权成功后尝试从Dropbox加载阅读进度...');

          // 加载阅读进度
          await progressSync.loadFromDropbox();

          // 尝试加载上次阅读的书籍
          const bookLoaded = await progressSync.loadCurrentBook();

          if (bookLoaded) {
            console.log('成功加载上次阅读的书籍');
            // 不显示成功消息，因为已经加载了书籍
          } else {
            console.log('没有找到上次阅读的书籍或加载失败');
            // 显示成功消息
            alert('成功连接到 Dropbox！');
          }
        } catch (error) {
          console.error('加载阅读进度或书籍时出错:', error);
          // 显示成功消息
          alert('成功连接到 Dropbox！');
        }

      } catch (error) {
        console.error('交换令牌时出错:', error);
        alert(`获取访问令牌时出错: ${error.message}`);
      }
    }

    // 更新 Dropbox 授权 UI
    function updateDropboxAuthUI(isAuthorized) {
      const connectContainer = document.getElementById('dropbox-connect-container');
      const booksContainer = document.getElementById('dropbox-books-container');

      if (isAuthorized) {
        // 已授权状态：显示书籍容器，隐藏连接按钮
        if (connectContainer) connectContainer.style.display = 'none';
        if (booksContainer) booksContainer.style.display = 'flex';

        // 加载 Dropbox 中的书籍
        loadDropboxBooks();
      } else {
        // 未授权状态：显示连接按钮，隐藏书籍容器
        if (connectContainer) connectContainer.style.display = 'flex';
        if (booksContainer) booksContainer.style.display = 'none';
      }
    }

    // 从 Dropbox 加载书籍
    async function loadDropboxBooks() {
      try {
        const accessToken = localStorage.getItem('dropboxAccessToken');
        if (!accessToken) {
          console.error('未找到 Dropbox 访问令牌');
          return;
        }

        console.log('正在从 Dropbox 加载书籍...');

        // 构建请求体
        const requestBody = {
          path: '', // 根目录
          recursive: true,
          include_media_info: false,
          include_deleted: false,
          include_has_explicit_shared_members: false,
          include_mounted_folders: true,
          include_non_downloadable_files: false
        };

        console.log('列出文件夹请求体:', JSON.stringify(requestBody));

        // 列出 Dropbox 中的文件
        const response = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          // 尝试获取更详细的错误信息
          let errorMessage = `Dropbox API 错误: ${response.status}`;
          try {
            const errorData = await response.text();
            console.error('列出文件夹错误详情:', errorData);
            errorMessage += ` - ${errorData}`;
          } catch (e) {
            console.error('无法解析列表错误详情:', e);
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();

        // 过滤出 EPUB 文件
        const epubFiles = data.entries.filter(entry =>
          entry.name.toLowerCase().endsWith('.epub') && entry['.tag'] === 'file'
        );

        console.log(`找到 ${epubFiles.length} 本 EPUB 书籍`);

        // 显示书籍
        displayDropboxBooks(epubFiles);
      } catch (error) {
        console.error('加载 Dropbox 书籍失败:', error);
        alert('无法加载 Dropbox 中的书籍，请重试。');
      }
    }

    // 显示 Dropbox 中的书籍
    function displayDropboxBooks(books) {
      const booksGrid = document.getElementById('books-grid');
      if (!booksGrid) return;

      // 清空现有内容
      booksGrid.innerHTML = '';

      if (books.length === 0) {
        // 没有书籍时显示提示
        const emptyMessage = document.createElement('div');
        emptyMessage.className = 'empty-message';
        emptyMessage.textContent = '没有找到 EPUB 书籍，请点击 + 添加';
        emptyMessage.style.color = 'rgba(255, 255, 255, 0.7)';
        emptyMessage.style.padding = '0 20px';
        booksGrid.appendChild(emptyMessage);
        return;
      }

      // 添加每本书
      books.forEach(book => {
        const bookCard = createBookCard(book);
        booksGrid.appendChild(bookCard);
      });
    }

    // 根据Dropbox API文档，处理HTTP头中的JSON
    function httpHeaderSafeJson(obj) {
      return JSON.stringify(obj).replace(/[\u007f-\uffff]/g, function(c) {
        return '\\u' + ('000' + c.charCodeAt(0).toString(16)).slice(-4);
      });
    }

    // 处理可能包含非ASCII字符的路径
    function sanitizeDropboxPath(path) {
      // 检查路径是否包含非ASCII字符
      const hasNonAscii = /[^\x00-\x7F]/.test(path);

      if (hasNonAscii) {
        console.log(`路径包含非ASCII字符: ${path}`);
        console.warn('文件路径包含非ASCII字符，使用Dropbox官方编码方式处理');
      }

      // 不需要修改路径本身，而是在构建API参数时使用httpHeaderSafeJson函数
      return path;
    }

    // 封面缓存管理
    const coverCache = {
      async get(bookId) {
        try {
          return localStorage.getItem(`book-cover-${bookId}`);
        } catch (e) {
          console.error('获取封面缓存失败:', e);
          return null;
        }
      },

      async set(bookId, coverUrl) {
        try {
          localStorage.setItem(`book-cover-${bookId}`, coverUrl);
        } catch (e) {
          console.error('保存封面缓存失败:', e);
        }
      }
    };

    // 从EPUB文件提取封面
    async function extractCoverFromEpub(file) {
      return new Promise((resolve, reject) => {
        try {
          console.log('开始提取封面:', file.name);

          // 检查是否已经有缓存的封面
          const bookId = file.name;
          coverCache.get(bookId).then(cachedCover => {
            if (cachedCover) {
              console.log('使用缓存的封面:', bookId);
              resolve(cachedCover);
              return;
            }

            // 没有缓存，需要提取封面
            console.log('没有缓存的封面，开始提取');

            // 创建临时的Book对象
            const book = ePub();

            // 使用FileReader读取文件
            const reader = new FileReader();
            reader.onload = function(e) {
              const arrayBuffer = e.target.result;

              // 打开EPUB文件
              book.open(arrayBuffer)
                .then(() => {
                  // 尝试获取封面
                  return book.loaded.cover;
                })
                .then(coverPath => {
                  if (!coverPath) {
                    console.log('EPUB文件没有封面:', file.name);
                    resolve(null);
                    return;
                  }

                  console.log('找到封面路径:', coverPath);

                  // 获取封面URL
                  return book.archive.createUrl(coverPath, { base64: true });
                })
                .then(coverUrl => {
                  if (coverUrl) {
                    console.log('成功提取封面URL');

                    // 缓存封面URL
                    coverCache.set(bookId, coverUrl);

                    resolve(coverUrl);
                  } else {
                    console.log('无法创建封面URL');
                    resolve(null);
                  }
                })
                .catch(error => {
                  console.error('提取封面时出错:', error);
                  resolve(null);
                });
            };

            reader.onerror = function(error) {
              console.error('读取文件时出错:', error);
              resolve(null);
            };

            reader.readAsArrayBuffer(file);
          });
        } catch (error) {
          console.error('提取封面过程中出错:', error);
          resolve(null);
        }
      });
    }

    // 从Dropbox下载文件并提取封面
    async function extractCoverFromDropbox(path) {
      try {
        const accessToken = localStorage.getItem('dropboxAccessToken');
        if (!accessToken) {
          console.error('未找到Dropbox访问令牌');
          return null;
        }

        // 检查缓存
        const bookId = path.split('/').pop();
        const cachedCover = await coverCache.get(bookId);
        if (cachedCover) {
          console.log('使用缓存的Dropbox封面:', bookId);
          return cachedCover;
        }

        console.log('从Dropbox下载文件以提取封面:', path);

        // 使用Dropbox API下载文件
        const argObj = { path: path };
        const safeArg = httpHeaderSafeJson(argObj);

        const response = await fetch('https://content.dropboxapi.com/2/files/download', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/octet-stream',
            'Dropbox-API-Arg': safeArg
          }
        });

        if (!response.ok) {
          console.error('从Dropbox下载文件失败:', response.status);
          return null;
        }

        // 获取文件内容
        const arrayBuffer = await response.arrayBuffer();

        // 获取文件名
        const fileName = path.split('/').pop();

        // 创建File对象
        const blob = new Blob([arrayBuffer], {type: 'application/epub+zip'});
        const file = new File([blob], fileName, {type: 'application/epub+zip'});

        // 提取封面
        return await extractCoverFromEpub(file);
      } catch (error) {
        console.error('从Dropbox提取封面失败:', error);
        return null;
      }
    }

    // 创建书籍卡片
    function createBookCard(book) {
      const card = document.createElement('div');
      card.className = 'book-card';

      // 创建封面容器
      const cover = document.createElement('div');
      cover.className = 'book-cover';

      // 创建加载指示器
      const loadingIndicator = document.createElement('div');
      loadingIndicator.className = 'cover-loading';
      loadingIndicator.textContent = '...';
      cover.appendChild(loadingIndicator);

      // 获取书名（去掉.epub后缀）
      const bookName = book.name.replace('.epub', '');

      // 创建信息
      const info = document.createElement('div');
      info.className = 'book-info';

      const title = document.createElement('div');
      title.className = 'book-title';
      title.textContent = bookName;

      // 检查是否包含非ASCII字符
      if (/[^\x00-\x7F]/.test(book.name)) {
        // 添加警告标记
        title.style.color = '#ffcc00';
        title.title = '此文件名包含中文或特殊字符，可能无法正常加载';
      }

      info.appendChild(title);

      // 组装卡片
      card.appendChild(cover);
      card.appendChild(info);

      // 添加点击事件
      card.addEventListener('click', function(event) {
        event.stopPropagation();

        // 使用处理过的路径
        const sanitizedPath = sanitizeDropboxPath(book.path_lower);
        console.log(`处理后的路径: ${sanitizedPath}`);

        loadBookFromDropbox(sanitizedPath);
        closeDrawer();
      });

      // 异步加载封面
      setTimeout(() => {
        extractCoverFromDropbox(book.path_lower).then(coverUrl => {
          // 移除加载指示器
          if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
          }

          if (coverUrl) {
            // 设置封面图片
            cover.style.backgroundImage = `url(${coverUrl})`;
            cover.style.backgroundSize = 'cover';
            cover.style.backgroundPosition = 'center';
            cover.style.backgroundRepeat = 'no-repeat';
            cover.textContent = '';
          } else {
            // 如果没有封面，显示首字母
            cover.textContent = bookName.charAt(0).toUpperCase();
            cover.style.display = 'flex';
            cover.style.alignItems = 'center';
            cover.style.justifyContent = 'center';
            cover.style.fontSize = '24px';
          }
        });
      }, 10);

      return card;
    }

    // 从 Dropbox 加载书籍
    async function loadBookFromDropbox(path) {
      try {
        const accessToken = localStorage.getItem('dropboxAccessToken');
        if (!accessToken) {
          console.error('未找到 Dropbox 访问令牌');
          return;
        }

        console.log(`正在从 Dropbox 加载书籍: ${path}`);

        // 使用Dropbox官方推荐的方式处理API参数
        // 创建参数对象
        const argObj = { path: path };

        // 使用httpHeaderSafeJson函数处理JSON，确保非ASCII字符被正确编码
        const safeArg = httpHeaderSafeJson(argObj);

        console.log('安全编码后的Dropbox API参数:', safeArg);

        // 创建请求头
        const headers = {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/octet-stream',
          'Dropbox-API-Arg': safeArg
        };

        console.log('发送请求头:', JSON.stringify(headers));

        // 下载文件
        const response = await fetch('https://content.dropboxapi.com/2/files/download', {
          method: 'POST',
          headers: headers
        });

        if (!response.ok) {
          // 尝试获取更详细的错误信息
          let errorMessage = `Dropbox API 错误: ${response.status}`;
          try {
            const errorData = await response.text();
            console.error('Dropbox API 错误详情:', errorData);
            errorMessage += ` - ${errorData}`;
          } catch (e) {
            console.error('无法解析错误详情:', e);
          }
          throw new Error(errorMessage);
        }

        // 获取文件内容
        const arrayBuffer = await response.arrayBuffer();

        // 获取文件名
        const fileName = path.split('/').pop();

        // 创建真正的Blob对象
        const blob = new Blob([arrayBuffer], {type: 'application/epub+zip'});

        // 创建真正的File对象
        const file = new File([blob], fileName, {type: 'application/epub+zip'});

        console.log('创建的File对象:', file);

        // 处理文件
        window.handleFile(file);
      } catch (error) {
        console.error('从 Dropbox 加载书籍失败:', error);
        alert('无法加载书籍，请重试。');
      }
    }

    // 检查 Dropbox 授权状态
    function checkDropboxAuthStatus() {
      const accessToken = localStorage.getItem('dropboxAccessToken');
      const tokenExpiry = localStorage.getItem('dropboxTokenExpiry');

      if (accessToken) {
        // 检查令牌是否过期
        if (tokenExpiry) {
          const now = new Date().getTime();
          if (now < parseInt(tokenExpiry)) {
            console.log('Dropbox 访问令牌有效');
            updateDropboxAuthUI(true);
            return true;
          } else {
            console.log('Dropbox 访问令牌已过期');
            // 这里可以添加刷新令牌的逻辑
          }
        } else {
          // 没有过期时间信息，假设令牌有效
          console.log('Dropbox 访问令牌存在（无过期信息）');
          updateDropboxAuthUI(true);
          return true;
        }
      }

      console.log('未连接 Dropbox 或令牌已过期');
      updateDropboxAuthUI(false);
      return false;
    }

    // 顶部抽屉控制函数
    function setupDrawer() {
      const drawerTrigger = document.getElementById('drawer-trigger');
      const topDrawer = document.getElementById('top-drawer');
      const uploadArea = document.getElementById('upload-area');
      const uploadBookInput = document.getElementById('upload-book');

      // 打开抽屉
      function openDrawer() {
        topDrawer.classList.add('open');
      }

      // 关闭抽屉
      function closeDrawer() {
        topDrawer.classList.remove('open');
      }

      // 全局可访问的关闭抽屉函数
      window.closeDrawer = closeDrawer;

      // 点击触发区域事件 - 切换抽屉显示状态
      drawerTrigger.addEventListener('click', function() {
        if (topDrawer.classList.contains('open')) {
          closeDrawer();
        } else {
          openDrawer();
        }
      });

      // 点击页面区域处理
      document.addEventListener('click', function(event) {
        // 如果抽屉是打开的，且点击的不是触发器，也不是抽屉本身，则关闭抽屉
        if (
          topDrawer.classList.contains('open') &&
          !drawerTrigger.contains(event.target) &&
          !topDrawer.contains(event.target)
        ) {
          // 关闭抽屉
          closeDrawer();
        }
      });

      // 设置 Dropbox 授权按钮事件
      const dropboxAuthButton = document.getElementById('dropbox-auth-button');
      if (dropboxAuthButton) {
        dropboxAuthButton.addEventListener('click', function(event) {
          // 阻止事件冒泡
          event.stopPropagation();
          // 处理 Dropbox 授权
          handleDropboxAuth();
        });
      }

      // 添加抽屉拖动功能
      const booksContainer = document.getElementById('dropbox-books-container');
      if (booksContainer) {
        let isDragging = false;
        let startX = 0;
        let scrollLeft = 0;

        // 鼠标按下事件
        booksContainer.addEventListener('mousedown', function(e) {
          isDragging = true;
          startX = e.pageX - booksContainer.offsetLeft;
          scrollLeft = booksContainer.scrollLeft;
        });

        // 鼠标移动事件
        booksContainer.addEventListener('mousemove', function(e) {
          if (!isDragging) return;
          e.preventDefault();
          const x = e.pageX - booksContainer.offsetLeft;
          const walkX = (x - startX) * 2; // 滚动速度
          booksContainer.scrollLeft = scrollLeft - walkX;
        });

        // 鼠标释放事件
        booksContainer.addEventListener('mouseup', function() {
          isDragging = false;
        });

        // 鼠标离开事件
        booksContainer.addEventListener('mouseleave', function() {
          isDragging = false;
        });

        // 触摸事件支持
        booksContainer.addEventListener('touchstart', function(e) {
          if (e.touches.length === 1) {
            isDragging = true;
            startX = e.touches[0].pageX - booksContainer.offsetLeft;
            scrollLeft = booksContainer.scrollLeft;
          }
        });

        booksContainer.addEventListener('touchmove', function(e) {
          if (!isDragging || e.touches.length !== 1) return;
          e.preventDefault(); // 防止页面滚动
          const x = e.touches[0].pageX - booksContainer.offsetLeft;
          const walkX = (x - startX) * 2;
          booksContainer.scrollLeft = scrollLeft - walkX;
        });

        booksContainer.addEventListener('touchend', function() {
          isDragging = false;
        });
      }

      // 上传区域点击事件
      if (uploadArea && uploadBookInput) {
        uploadArea.addEventListener('click', function(event) {
          // 阻止事件冒泡
          event.stopPropagation();
          uploadBookInput.click();
        });

        // 文件选择事件
        uploadBookInput.addEventListener('change', function(event) {
          const file = event.target.files[0];
          if (file && file.name.toLowerCase().endsWith('.epub')) {
            // 如果已连接 Dropbox，上传到 Dropbox
            const accessToken = localStorage.getItem('dropboxAccessToken');
            if (accessToken) {
              // 先提取封面，然后上传到Dropbox
              extractCoverFromEpub(file).then(() => {
                uploadToDropbox(file);
              });
            } else {
              // 否则直接处理文件
              // 先提取封面，然后处理文件
              extractCoverFromEpub(file).then(() => {
                window.handleFile(file);
              });
            }
            // 关闭抽屉
            closeDrawer();
          }
        });
      }
    }

    // 上传文件到 Dropbox
    async function uploadToDropbox(file) {
      try {
        const accessToken = localStorage.getItem('dropboxAccessToken');
        if (!accessToken) {
          console.error('未找到 Dropbox 访问令牌');
          return;
        }

        console.log(`正在上传文件到 Dropbox: ${file.name}`);

        // 读取文件内容
        const arrayBuffer = await file.arrayBuffer();

        // 准备Dropbox API参数
        const fileName = file.name;
        console.log(`准备上传文件: ${fileName}`);

        // 构建API参数对象
        const argObj = {
          path: `/${fileName}`,
          mode: 'add',
          autorename: true,
          mute: false
        };

        // 使用httpHeaderSafeJson函数处理JSON，确保非ASCII字符被正确编码
        const safeArg = httpHeaderSafeJson(argObj);
        console.log('安全编码后的上传参数:', safeArg);

        // 创建请求头
        const headers = {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/octet-stream',
          'Dropbox-API-Arg': safeArg
        };

        console.log('上传请求头:', JSON.stringify(headers));

        // 上传到 Dropbox
        const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
          method: 'POST',
          headers: headers,
          body: arrayBuffer
        });

        if (!response.ok) {
          // 尝试获取更详细的错误信息
          let errorMessage = `Dropbox API 错误: ${response.status}`;
          try {
            const errorData = await response.text();
            console.error('Dropbox API 上传错误详情:', errorData);
            errorMessage += ` - ${errorData}`;
          } catch (e) {
            console.error('无法解析上传错误详情:', e);
          }
          throw new Error(errorMessage);
        }

        console.log('文件上传成功');

        // 处理文件
        window.handleFile(file);

        // 刷新书籍列表
        loadDropboxBooks();
      } catch (error) {
        console.error('上传文件到 Dropbox 失败:', error);
        alert('上传文件到 Dropbox 失败，请重试。');

        // 如果上传失败，仍然处理文件
        window.handleFile(file);
      }
    }

    // 在全局作用域中定义handleFile函数，确保它在页面加载前就可用
    window.handleFile = function(file) {
      console.log('全局handleFile函数被调用，文件:', file ? file.name : 'undefined');

      // 如果文档已加载完成，直接处理文件
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        console.log('文档已加载，直接处理文件');
        // 这里不能直接调用handleFileInternal，因为它还没有定义
        // 相反，我们将文件保存到一个全局变量中，等待DOMContentLoaded事件处理
        window._pendingFile = file;
      } else {
        // 如果文档尚未加载完成，保存文件并等待DOMContentLoaded事件
        console.log('文档尚未加载，保存文件等待处理');
        window._pendingFile = file;
      }
    };

    document.addEventListener('DOMContentLoaded', async function() {
      // 设置顶部抽屉
      setupDrawer();

      // 检查 URL 中是否有授权码
      handleDropboxRedirect();

      // 检查 Dropbox 授权状态并更新 UI
      const isAuthorized = checkDropboxAuthStatus();

      // 检查ePub.js是否正确加载
      if (typeof ePub === 'undefined') {
        alert('Error: ePub.js library could not be loaded. Please check your internet connection and try again.');
        return;
      }

      // 如果已授权Dropbox，尝试加载阅读进度和上次阅读的书籍
      if (isAuthorized) {
        try {
          console.log('尝试从Dropbox加载阅读进度...');

          // 加载阅读进度
          await progressSync.loadFromDropbox();

          // 尝试加载上次阅读的书籍
          const bookLoaded = await progressSync.loadCurrentBook();

          if (bookLoaded) {
            console.log('成功加载上次阅读的书籍');
          } else {
            console.log('没有找到上次阅读的书籍或加载失败');
          }
        } catch (error) {
          console.error('加载阅读进度或书籍时出错:', error);
        }
      }
      // 获取DOM元素
      const dropArea = document.getElementById('drop-area');
      const epubViewer = document.getElementById('epub-viewer');
      const notesTextarea = document.getElementById('notes');
      const notesArea = document.getElementById('notes-area');
      const notesToggle = document.getElementById('notes-toggle');
      // 移除了调试按钮相关变量
      // 移除了紧急导航按钮相关变量

      // 全局变量
      let book;
      let rendition;  // 渲染器
      let currentBook = null;
      let currentNotes = {};
      let currentLocation = 0; // 当前位置
      let totalLocations = 0;  // 总位置数

      // 更新页面显示 - 全局函数
      function updatePages(startLocation) {
        // 确保位置在有效范围内
        if (startLocation < 0) startLocation = 0;
        if (startLocation >= totalLocations) startLocation = totalLocations - 1;

        // 更新当前位置
        currentLocation = startLocation;

        // 使用位置索引（转换为CFI）
        const cfi = book.locations.cfiFromLocation(startLocation);

        // 显示页面
        rendition.display(cfi).then(() => {
          // 更新进度显示
          updateProgressInfo();

          // 保存阅读进度到本地，但不保存到Dropbox（避免初始加载时频繁保存）
          if (currentBook) {
            // 只保存到本地，不保存到Dropbox
            progressSync.updateBookProgress(currentBook, currentLocation.toString(), false);
          }
        }).catch(error => {
          console.error('页面显示错误:', error);
        });
      }

      // 更新进度信息显示
      function updateProgressInfo() {
        if (!book || !rendition) return;

        try {
          // 计算百分比进度
          const percentage = Math.floor((currentLocation / totalLocations) * 100);

          // 构建进度信息
          let progressInfo = `${percentage}%`;

          // 添加位置信息
          progressInfo += ` | 位置: ${currentLocation+1}/${totalLocations}`;

          // 尝试获取当前章节信息
          try {
            const currentLoc = rendition.location;
            if (currentLoc && currentLoc.start) {
              // 获取章节路径
              const chapter = currentLoc.start.href || '';

              // 从章节路径中提取章节名称
              let chapterName = chapter.split('/').pop().replace('.html', '');

              // 尝试清理章节名称（移除数字前缀等）
              chapterName = chapterName.replace(/^\d+[\._-]?/, '');
              chapterName = chapterName.replace(/_/g, ' ');

              if (chapterName) {
                progressInfo += ` | ${chapterName}`;
              }

              // 尝试获取章节标题
              if (currentLoc.start.index) {
                const spineItem = book.spine.get(currentLoc.start.index);
                if (spineItem && spineItem.title) {
                  progressInfo += ` (${spineItem.title})`;
                }
              }
            }
          } catch (e) {
            // 忽略章节获取错误
          }

          // 更新页面信息显示
          const pageInfoElement = document.getElementById('page-info');
          if (pageInfoElement) {
            pageInfoElement.textContent = progressInfo;
          }

          // 更新右下角页码显示
          const pageCounterElement = document.getElementById('page-counter');
          if (pageCounterElement) {
            // 简洁显示：当前页/总页数
            pageCounterElement.textContent = `${currentLocation+1}/${totalLocations}`;
          }
        } catch (error) {
          console.error('更新进度信息出错:', error);
        }
      }

      // 将updateProgressInfo函数添加到window对象，使其在所有作用域中可用
      window.updateProgressInfo = updateProgressInfo;

      // 加载保存的笔记
      try {
        const savedNotes = localStorage.getItem('epub-reader-notes');
        if (savedNotes) {
          currentNotes = JSON.parse(savedNotes);
        }
      } catch (error) {
        console.error('Error loading saved notes:', error);
      }

      // 处理拖放事件 - 使用统一的处理函数
      // 处理拖放区域样式
      function handleDragOver(event) {
        event.preventDefault();

        // 如果库未加载完成，不处理
        if (!window.librariesReady) return;

        // 显示拖放区域
        if (dropArea.classList.contains('hidden')) {
          dropArea.classList.remove('hidden');
        }

        // 设置样式
        dropArea.style.borderColor = '#4a4238';
        dropArea.style.backgroundColor = 'rgba(74, 66, 56, 0.1)';
      }

      // 处理拖放离开
      function handleDragLeave() {
        // 如果库未加载完成，不处理
        if (!window.librariesReady) return;

        // 重置样式
        dropArea.style.borderColor = '#ccc';
        dropArea.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
      }

      // 处理文件拖放
      function handleFileDrop(event) {
        event.preventDefault();

        // 如果库未加载完成，显示提示
        if (!window.librariesReady) {
          alert('Libraries are still loading. Please wait a moment and try again.');
          console.log('Error: Libraries not ready yet');
          return;
        }

        // 重置样式
        dropArea.style.borderColor = '#ccc';
        dropArea.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';

        try {
          // 获取拖放的文件
          const file = event.dataTransfer.files[0];
          if (file && file.name.toLowerCase().endsWith('.epub')) {
            // 使用setTimeout延迟执行，给浏览器时间处理UI更新
            setTimeout(function() {
              try {
                // 处理新文件
                window.handleFile(file);
              } catch (error) {
                console.error('处理文件时出错:', error);
              }
            }, 100);
          }
        } catch (error) {
          console.error('处理拖放事件时出错:', error);
        }
      }

      // 为整个文档添加拖放事件
      document.addEventListener('dragover', handleDragOver);
      document.addEventListener('dragleave', handleDragLeave);
      document.addEventListener('drop', handleFileDrop);

      // 为dropArea也添加事件监听器（确保兼容性）
      dropArea.addEventListener('dragover', handleDragOver);
      dropArea.addEventListener('dragleave', handleDragLeave);
      dropArea.addEventListener('drop', handleFileDrop);

      // 移除了示例EPUB加载功能

      // 这里已经在前面定义了debounce函数，不需要重复定义

      // 保存笔记函数 - 提取为独立函数避免代码重复
      function saveNotes() {
        if (currentBook) {
          currentNotes[currentBook] = notesTextarea.value;
          localStorage.setItem('epub-reader-notes', JSON.stringify(currentNotes));
        }
      }

      // 使用防抖优化笔记保存 - 500ms内只保存一次
      const debouncedSaveNotes = debounce(saveNotes, 500);

      // 设置自动保存笔记 - 使用防抖函数
      notesTextarea.addEventListener('input', debouncedSaveNotes);

      // 添加笔记区域的焦点状态管理
      let isNotesActive = false; // 全局变量，跟踪笔记区域是否处于活动状态

      // 当笔记区域获得焦点时
      notesTextarea.addEventListener('focus', function() {
        isNotesActive = true;
        // 可以在这里添加视觉提示，例如改变边框颜色
        notesTextarea.style.outline = '2px solid #4a4238';
      });

      // 当笔记区域失去焦点时
      notesTextarea.addEventListener('blur', function() {
        isNotesActive = false;
        // 移除视觉提示
        notesTextarea.style.outline = 'none';

        // 立即保存笔记内容（不使用防抖）
        saveNotes();
      });

      // 更新笔记区域的箭头方向
      function updateNotesToggleIcon(isExpanded) {
        const icon = notesToggle.querySelector('.icon');
        if (isExpanded) {
          icon.textContent = '<'; // 展开状态显示左箭头（指向收起方向）
        } else {
          icon.textContent = '>'; // 收起状态显示右箭头（指向展开方向）
        }
      }

      // 重新渲染电子书函数 - 提取为独立函数避免代码重复
      function rerenderBook() {
        if (!book || !rendition) return;

        // 获取当前容器尺寸
        const container = document.getElementById('epub-container');
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;

        // 调整渲染器尺寸
        rendition.resize(newWidth, newHeight);

        // 使用当前位置重新渲染
        try {
          const location = rendition.location;
          if (location && location.start) {
            rendition.display(location.start.cfi);
          } else {
            // 如果无法获取当前位置，使用保存的位置
            const cfi = book.locations.cfiFromLocation(currentLocation);
            rendition.display(cfi);
          }
        } catch (error) {
          // 使用保存的位置
          const cfi = book.locations.cfiFromLocation(currentLocation);
          rendition.display(cfi);
        }
      }

      // 设置笔记区域的展开状态
      function setNotesAreaExpanded(isExpanded, rerender = true) {
        // 更新DOM状态
        if (isExpanded) {
          notesArea.classList.add('expanded');
        } else {
          notesArea.classList.remove('expanded');
        }

        // 更新箭头方向
        updateNotesToggleIcon(isExpanded);

        // 保存状态到本地存储
        localStorage.setItem('notes-expanded', isExpanded ? 'true' : 'false');

        // 如果需要重新渲染，且书籍和渲染器已加载
        if (rerender && book && rendition) {
          // 清除可能存在的旧事件监听器
          notesArea.removeEventListener('transitionend', rerenderBook);

          // 添加过渡结束事件监听器，只在过渡动画结束时重新渲染一次
          notesArea.addEventListener('transitionend', rerenderBook, { once: true });

          // 为了兼容性，也添加一个备用的定时器，确保即使transitionend事件没有触发也能重新渲染
          if (window.notesAnimationTimer) {
            clearTimeout(window.notesAnimationTimer);
          }
          window.notesAnimationTimer = setTimeout(rerenderBook, 350); // 略大于CSS过渡时间
        }
      }

      // 处理笔记区域的展开/收起
      notesToggle.addEventListener('click', function() {
        const isExpanded = !notesArea.classList.contains('expanded');
        setNotesAreaExpanded(isExpanded);
      });

      // 恢复笔记区域状态
      function restoreNotesAreaState() {
        const expanded = localStorage.getItem('notes-expanded') === 'true';
        setNotesAreaExpanded(expanded, false); // 不重新渲染，因为此时书籍可能尚未加载
      }

      // 页面加载时恢复笔记区域状态
      restoreNotesAreaState();

      // 卸载当前书籍 - 极简版本
      function unloadCurrentBook() {
        try {
          // 保存当前笔记
          if (currentBook && notesTextarea) {
            currentNotes[currentBook] = notesTextarea.value;
            localStorage.setItem('epub-reader-notes', JSON.stringify(currentNotes));
          }

          // 保存当前阅读进度到本地和Dropbox
          if (currentBook && currentLocation >= 0) {
            // 使用进度同步模块更新进度，并指定保存到云端
            progressSync.updateBookProgress(currentBook, currentLocation.toString(), true);
          }

          // 清空容器 - 这是最重要的部分
          const epubContainer = document.getElementById('epub-container');
          if (epubContainer) {
            epubContainer.innerHTML = '';
          }

          // 简单地重置变量，不尝试清理对象
          book = null;
          rendition = null;

          // 强制垃圾回收（尽管这不是直接的方法）
          if (window.gc) {
            window.gc();
          }

        } catch (e) {
          console.error('卸载书籍时出错:', e);

          // 即使出错，也要确保容器被清空
          try {
            const epubContainer = document.getElementById('epub-container');
            if (epubContainer) {
              epubContainer.innerHTML = '';
            }

            // 重置变量
            book = null;
            rendition = null;
          } catch (innerError) {
            console.error('清空容器时出错:', innerError);
          }
        }
      }

      // 这个函数将在DOMContentLoaded事件处理程序中使用
      function handleFileInternal(file) {
        // 检查库是否已加载
        if (!window.librariesReady) {
          alert('Libraries are still loading. Please wait a moment and try again.');
          return;
        }

        // 检查是否是EPUB文件
        if (!file.name.toLowerCase().endsWith('.epub')) {
          alert('Please upload an EPUB file.');
          return;
        }

        // 如果当前已有书籍加载，先卸载它
        unloadCurrentBook();

        // 设置当前书籍
        currentBook = file.name;

        // 隐藏拖放区域
        dropArea.classList.add('hidden');

        try {
          // 检查JSZip是否已加载
          if (typeof JSZip === 'undefined') {
            throw new Error('JSZip library is not loaded. Cannot process EPUB file.');
          }

          // 检查ePub.js是否已加载
          if (typeof ePub === 'undefined') {
            throw new Error('ePub.js library is not loaded. Cannot process EPUB file.');
          }

          try {
            // 创建book对象
            book = ePub();

            // 添加必要的事件监听器
            book.on('rendition:error', function(error) {
              console.error('渲染错误:', error);
            });

            // 检查文件是否是有效的File或Blob对象
            if (!(file instanceof Blob)) {
              console.error('文件不是有效的Blob对象:', file);
              alert('文件格式错误，无法加载。');
              return;
            }

            console.log('处理文件:', file);

            // 使用FileReader读取文件为ArrayBuffer
            const reader = new FileReader();

            reader.onload = function(e) {
              const arrayBuffer = e.target.result;
              console.log('文件读取成功，大小:', arrayBuffer.byteLength);

              // 使用ArrayBuffer打开文件
              book.open(arrayBuffer)
                .then(function() {
                // 清空容器，确保没有残留内容
                const epubContainer = document.getElementById('epub-container');
                if (epubContainer) {
                  epubContainer.innerHTML = '';
                } else {
                  console.error('找不到epub-container元素，无法清空内容');
                }

                // 获取容器尺寸
                const container = document.getElementById('epub-container');
                const containerWidth = container ? container.clientWidth : 0;
                const containerHeight = container ? container.clientHeight : 0;
                rendition = book.renderTo('epub-container', {
                  width: containerWidth,
                  height: containerHeight,
                  spread: 'both',  // 启用双页显示
                  flow: 'paginated',
                  manager: 'default',
                  allowScriptedContent: true,
                  allowPopups: false,
                });

                // 生成位置信息
                book.ready.then(() => {
                  // 检查是否有保存的位置信息
                  const storedLocations = localStorage.getItem(`${currentBook}-locations`);

                  if (storedLocations) {
                    // 如果有保存的位置信息，直接加载
                    return book.locations.load(JSON.parse(storedLocations));
                  } else {
                    // 否则生成新的位置信息
                    return book.locations.generate(1024).then(locations => {
                      // 保存位置信息到本地存储
                      localStorage.setItem(`${currentBook}-locations`, JSON.stringify(locations));
                      return locations;
                    });
                  }
                }).then((locations) => {
                  totalLocations = book.locations.total;

                  // 检查是否有保存的阅读进度
                  const storedProgress = localStorage.getItem(`${currentBook}-progress`);
                  let startLocation = 0;

                  if (storedProgress) {
                    try {
                      startLocation = parseInt(storedProgress, 10);
                    } catch (e) {
                      // 解析失败，使用默认值0
                    }
                  }

                  // 初始化显示
                  updatePages(startLocation);

                  // 移除了重复的滚轮事件监听器设置，改为在rendered事件中添加
                }).catch(error => {
                  console.error('位置信息处理错误:', error);
                });

                // 添加键盘事件处理
                rendition.on('keydown', function(e) {
                  handleKeyNavigation(e.key);
                });

                // 统一的键盘导航处理函数
                function handleKeyNavigation(key) {
                  if(key == "ArrowLeft") {
                    navigatePrev();
                  }
                  if(key == "ArrowRight") {
                    navigateNext();
                  }
                }

                // 注意：移除了这里的iframe sandbox设置，因为在rendered事件中已经设置了

                // 检查渲染器是否正确创建
                if (!rendition) {
                  throw new Error('Failed to create rendition');
                }

                // 监听但不处理点击事件
                rendition.on('click', function(event) {
                  // 不再尝试阻止默认行为，而是使用自定义处理
                  // 这里可以添加自定义点击处理逻辑，如显示菜单等
                });

                // 添加位置变化事件监听
                rendition.on('relocated', function(location) {
                  if (location && location.start) {
                    try {
                      const locationCfi = location.start.cfi;
                      const newLocation = book.locations.locationFromCfi(locationCfi);

                      console.log(`位置变化: ${currentLocation} -> ${newLocation}`);

                      if (newLocation !== currentLocation) {
                        currentLocation = newLocation;

                        // 更新进度显示
                        window.updateProgressInfo();

                        // 保存阅读进度到本地存储（这个操作很快，可以立即执行）
                        if (currentBook) {
                          localStorage.setItem(`${currentBook}-progress`, currentLocation.toString());

                          // 清除之前的保存计时器（如果有）
                          if (window.saveProgressTimer) {
                            clearTimeout(window.saveProgressTimer);
                          }

                          // 设置新的计时器，用户停留2秒后再保存到Dropbox
                          window.saveProgressTimer = setTimeout(() => {
                            console.log(`用户停留超过2秒，保存阅读进度到Dropbox: ${currentBook}, 位置: ${currentLocation}`);

                            // 使用进度同步模块更新进度，并指定保存到云端
                            progressSync.updateBookProgress(currentBook, currentLocation.toString(), true);
                          }, 2000); // 2秒后触发保存
                        } else {
                          console.warn('无法保存进度：currentBook未定义');
                        }
                      }
                    } catch (e) {
                      console.error('更新位置时出错:', e);
                    }
                  }
                });

                // 添加内容加载事件监听器
                rendition.on('rendered', function(section) {
                  // 内容渲染后，添加滚轮事件监听器到新的内容
                  setTimeout(function() {
                    try {
                      // 查找iframe
                      const container = document.getElementById('epub-container');
                      if (!container) return;

                      const iframe = container.querySelector('iframe');
                      if (!iframe) return;

                      // 确保iframe已加载
                      if (!iframe.contentDocument && !iframe.contentWindow) return;

                      // 访问iframe的内容文档
                      const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                      if (!iframeDoc) return;

                      // 设置sandbox属性
                      iframe.sandbox = 'allow-same-origin allow-scripts';

                      // 为iframe内部添加拖放事件处理
                      // 阻止默认行为，防止触发浏览器的另存为对话框
                      iframeDoc.addEventListener('dragover', function(e) {
                        e.preventDefault();

                        // 显示拖放区域
                        if (dropArea && dropArea.classList.contains('hidden')) {
                          dropArea.classList.remove('hidden');
                        }
                      });

                      // 处理iframe内部的文件拖放
                      iframeDoc.addEventListener('drop', function(e) {
                        e.preventDefault();

                        try {
                          // 获取拖放的文件并处理
                          const file = e.dataTransfer.files[0];
                          if (file && file.name.toLowerCase().endsWith('.epub')) {
                            // 使用setTimeout延迟执行，给浏览器时间处理UI更新
                            setTimeout(function() {
                              try {
                                // 处理新文件
                                window.handleFile(file);
                              } catch (error) {
                                console.error('处理文件时出错:', error);
                              }
                            }, 100);
                          }
                        } catch (error) {
                          console.error('处理拖放事件时出错:', error);
                        }
                      });

                      // 创建滚轮事件监听器
                      const wheelListener = function(event) {
                        // 不再尝试阻止默认行为，而是直接处理滚动

                        // 设置滚动阈值和冷却时间
                        const now = Date.now();
                        if (now - (window.lastWheelTime || 0) < 50) return;
                        window.lastWheelTime = now;

                        // 根据滚动方向导航
                        if (event.deltaY > 2) {
                          // 向下滚动，前进到下一页
                          window.navigateNext();
                        } else if (event.deltaY < -2) {
                          // 向上滚动，后退到上一页
                          window.navigatePrev();
                        }
                      };

                      // 添加监听器，使用passive: true以避免警告
                      iframeDoc.addEventListener('wheel', wheelListener, { passive: true });

                      // 添加点击事件监听器，确保点击iframe内容时也能关闭抽屉
                      iframeDoc.addEventListener('click', function(e) {
                        // 获取顶部抽屉元素
                        const topDrawer = document.getElementById('top-drawer');
                        // 如果抽屉是打开的，关闭它
                        if (topDrawer && topDrawer.classList.contains('open')) {
                          // 调用全局关闭抽屉函数
                          window.closeDrawer();
                        }
                      });
                    } catch (e) {
                      console.error('添加事件监听器时出错:', e);
                    }
                  }, 200);
                });

                // 不需要在这里显示书籍，因为我们会在生成位置信息后调用updatePages(0)
              })
              .then(function() {
                // 加载元数据
                return book.loaded.metadata;
              })
              .then(function(metadata) {
                // 元数据加载完成
              })
              .catch(function(error) {
                alert('Error loading EPUB: ' + error.message);
              });
            };

            reader.onerror = function(error) {
              alert('Error reading file: ' + error);
            };

            // 开始读取文件
            reader.readAsArrayBuffer(file);
          } catch (error) {
            alert('Critical error initializing ePub reader: ' + error.message);
          }

          // 加载笔记
          if (currentNotes[currentBook]) {
            notesTextarea.value = currentNotes[currentBook];
          } else {
            notesTextarea.value = '';
          }

          // 设置键盘导航
          document.addEventListener('keydown', handleKeyPress);

          // 添加窗口大小调整事件监听器 - 使用节流版本
          window.addEventListener('resize', throttledResize);

        } catch (error) {
          console.error('Error in handleFile:', error);
          alert('Error loading EPUB: ' + error.message);
        }
      }

      // 处理键盘导航
      function handleKeyPress(event) {
        if (!book || !rendition) return;

        // 检查笔记区域是否处于活动状态
        if (isNotesActive) return;

        // 检查是否有其他文本输入元素处于焦点状态
        const activeElement = document.activeElement;
        const isInputActive = activeElement.tagName === 'INPUT' ||
                             activeElement.tagName === 'TEXTAREA' ||
                             activeElement.isContentEditable;

        // 如果有输入元素处于焦点状态，不处理键盘导航
        if (isInputActive) return;

        // 只处理箭头键，不阻止默认行为
        if (event.key === 'ArrowLeft') {
          window.navigatePrev();
        } else if (event.key === 'ArrowRight') {
          window.navigateNext();
        }
      }

      // 更新阅读位置函数 - 提取为独立函数避免代码重复
      function updateReadingPosition() {
        try {
          const location = rendition.location;
          if (location && location.start) {
            const locationCfi = location.start.cfi;
            const newLocation = book.locations.locationFromCfi(locationCfi);
            currentLocation = newLocation;

            // 更新进度显示
            window.updateProgressInfo();

            // 保存阅读进度到本地和Dropbox
            if (currentBook) {
              // 使用进度同步模块更新进度
              progressSync.updateBookProgress(currentBook, currentLocation.toString());
            }
          }
        } catch (e) {
          console.error('更新位置时出错:', e);
        }
      }

      // 导航到上一页 - 使用ePub.js内置方法
      function navigatePrev() {
        if (!book || !rendition) return;

        // 使用rendition的prev方法导航到上一页
        rendition.prev().then(function() {
          // 导航成功后更新当前位置
          setTimeout(updateReadingPosition, 100);
        }).catch(function() {
          // 已经是第一页
        });
      }

      // 导航到下一页 - 使用ePub.js内置方法
      function navigateNext() {
        if (!book || !rendition) return;

        // 使用rendition的next方法导航到下一页
        rendition.next().then(function() {
          // 导航成功后更新当前位置
          setTimeout(updateReadingPosition, 100);
        }).catch(function() {
          // 已经是最后一页
        });
      }

      // 将导航函数添加到window对象，使其在所有作用域中可用
      window.navigatePrev = navigatePrev;
      window.navigateNext = navigateNext;

      // 节流函数 - 用于限制函数执行频率
      function throttle(func, wait) {
        let lastTime = 0;
        return function() {
          const now = Date.now();
          if (now - lastTime >= wait) {
            lastTime = now;
            func.apply(this, arguments);
          }
        };
      }

      // 处理窗口大小调整
      function handleResize() {
        if (!book || !rendition) {
          return;
        }

        // 使用之前创建的rerenderBook函数重新渲染
        rerenderBook();

        // 在拖动结束后进行一次完整渲染
        // 这是为了确保在拖动结束后内容完全正确
        if (window.finalResizeTimer) {
          clearTimeout(window.finalResizeTimer);
        }
        window.finalResizeTimer = setTimeout(rerenderBook, 300); // 拖动结束后300ms进行最终渲染
      }

      // 使用节流函数包装handleResize，限制执行频率
      const throttledResize = throttle(handleResize, 50); // 50ms的节流间隔

      // 将handleFile函数添加到window对象，使其在全局可用
      window.handleFile = handleFileInternal;

      // 检查是否有待处理的文件
      if (window._pendingFile) {
        console.log('处理待处理的文件:', window._pendingFile.name);
        handleFileInternal(window._pendingFile);
        window._pendingFile = null;
      }
    });
  </script>
</body>
</html>
